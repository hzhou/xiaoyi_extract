module: python

#L N  Epoch  Energy k ... c0o0b0  c0o0b1  c0o1b0 ... c1o0b0 c1o0b1  c1o1b0 ...
# c - channel / detector 3
# o - orbital
# b - bunch  n bunch / orbit
# trigger - bunch # since c*o0b0


page: trxas_extract
    # output_dir: /home/hzhou/projects/jupyter
    $import numpy as np
    $import re
    t = Extract()
    # t.read("data/sample3-00156")
    t.read("data/monomer-00029")
    print("  %s cols, %s rows" % (t.num_cols, t.num_rows))
    # t.process_perbunch('data/t.out', 29, 4, 2, 4)
    t.process_avgbunch('data/t.out', 229, 4, 2, 4)

subcode: _autoload
    $call class_RE
    class Extract:
        def is_sample_data(file):
            f = open(file, 'r')
            line = f.readline()
            $if re.match(r'#F \S+$', line)
                return True
            $else
                return False

        def read(self, file):
            $call read_trxas
        def process_perbunch(self, fileout, trig, pre_n_avg, aft_n_avg, n_pnt):
            $(set:mode=perbunch)
            $call process_trxas
        def process_avgbunch(self, fileout, trig, pre_n_avg, aft_n_avg, n_pnt):
            $(set:mode=avgbunch)
            $call process_trxas

subcode: process_trxas
    extra_cols = ["Energy"]
    header_cols = []
    header_cols.extend(extra_cols)
    $for j=0:n_pnt
        header_cols.append("b%d" % j)
        header_cols.append("b%d-diff" % j)

    data_out = np.empty([self.num_rows, len(header_cols)])

    num_extra = len(extra_cols)
    $for i, col in extra_cols
        data_out[:, i] = self.data[:, self.idxs[col]]

    $for i=0:self.num_rows
        row_in = self.data[i,:]
        row_out = data_out[i,num_extra:]
        $call calc_background, pre_n_avg
        $call out_line_b_diff, aft_n_avg

    np.savetxt(fileout, data_out, header=' '.join(header_cols), fmt='%.6f', comments='')

    subcode: calc_background(pre_n_avg) # row_in
        back0, back1, back2, back12 = [], [], [], []

        $for i=0:self.o_jump # each bunch
            (t0, t1, t2, t12) = (0, 0, 0, 0)
            i0 = self.idxs['c0o0b0'] + trig + i
            $for j=0:$(pre_n_avg)
                $call acc_t012, i0 - (j+1) * self.o_jump
            $call avg_t012, $(pre_n_avg)

            $(for:0,1,2,12)
                back$1.append(t$1)
        $(if:mode=avgbunch)
            $(for:0,1,2,12)
                back$1_avg = np.mean(back$1)
        
    subcode: out_line_b_diff(aft_n_avg)
        $for j=0:n_pnt
            a12 = 0
            adiff = 0
            i0 = self.idxs['c0o0b0'] + trig + j*$(aft_n_avg)
            $for i=0:$(aft_n_avg)
                $call get_t012, i0 + i
                $call avg_t012

                $(if:mode=perbunch)
                    b_idx=(i+j*$(aft_n_avg)) % self.o_jump
                    diff = t12 - back12[b_idx]
                $(elif:mode=avgbunch)
                    diff = t12 - back12_avg

                a12+=t12
                adiff+=diff

            a12/=$(aft_n_avg)
            adiff/=$(aft_n_avg)

            row_out[j*2] = a12
            row_out[j*2 + 1] = adiff

    #------------------
    subcode: get_t012(i)
        t0=row_in[$(i)]
        t1=row_in[$(i)+self.c_jump]
        t2=row_in[$(i)+self.c_jump*2]
    subcode: acc_t012(i)
        t0+=row_in[$(i)]
        t1+=row_in[$(i)+self.c_jump]
        t2+=row_in[$(i)+self.c_jump*2]
    subcode: avg_t012(@n)
        $(if:n)
            t0 /= $(pre_n_avg)
            t1 /= $(pre_n_avg)
            t2 /= $(pre_n_avg)
        t1/=t0
        t2/=t0
        t12=(t1+t2)/2


subcode: read_trxas # file
    header = None
    rows = []
    with open(file) as f:
        $for line in f
            $if line.startswith('#L ')
                header = line[3:]
            $elif re.match(r'\d.*', line) and header
                rows.append(line)
    $call parse_header
    $call check_header
    self.num_cols = len(rows[0].split())
    self.num_rows = len(rows)
    self.data = np.empty([self.num_rows, self.num_cols], dtype = np.float64)
    $for i, l in rows
        $for j, t in l.split()
            self.data[i, j] = float(t)

    subcode: parse_header
        self.cols = header.split()
        self.idxs = {}
        $(for:c,o,b)
            self.$1_min = 999
            self.$1_max = 0

        $foreach i, col in self.cols
            $call update_col_cob
            self.idxs[col] = i    

        self.c_jump = self.idxs['c1o0b0'] - self.idxs['c0o0b0']
        self.o_jump = self.b_max+1

        subcode: update_col_cob
            $if RE.match(r'c(\d+)o(\d+)b(\d+)', col)
                $(for:c,o,b and 1,2,3)
                    self.$1_max = max(self.$1_max, int(RE.m.group($2)))
                    self.$1_min = min(self.$1_min, int(RE.m.group($2)))

    subcode: check_header
        $(for:c,o,b)
            $call assert, self.$1_min==0
        $call assert, self.c_max>=2
        $call assert, self.idxs['c0o0b0']
        $call assert, self.idxs['c1o0b0']

        subcode: assert(cond)
            $if !($(cond))
                raise Exception("assert error: ! [$(cond)]\n")

