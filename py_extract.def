#L N  Epoch  Energy k ... c0o0b0  c0o0b1  c0o1b0 ... c1o0b0 c1o0b1  c1o1b0 ...
# c - channel / detector 3
# o - orbital
# b - bunch  n bunch / orbit
# trigger - bunch # since c*o0b0


page: trxas_extract
    module: python
    # output_dir: /home/hzhou/projects/jupyter
    $import numpy as np
    $import re
    t = Extract()
    # t.read("data/sample3-00156")
    t.read("data/monomer-00029")
    t.normalize()
    print("  %s cols, %s rows" % (t.num_cols, t.num_rows))
    # t.process_perbunch('data/t.out', 29, 4, 2, 4)
    # t.process_avgbunch('data/t.out', 229, 4, 2, 4)
    print(Extract.average_output("data", 156, 156))

subcode: _autoload
    $call class_RE
    class Extract:
        # -- class methods --
        def is_sample_data(file):
            f = open(file, 'r')
            line = f.readline()
            $if re.match(r'#F \S+$', line)
                return True
            $else
                return False

        def average_output(folder, idx_min, idx_max):
            def get_header(file):
                f = open(file, 'r')
                header = f.readline()
                f.close()
                return header.rstrip()

            $import os, os.path
            header_line = None
            data = []
            $for filename in os.listdir(folder)
                $if filename.startswith('avg')
                    continue
                m = re.match(r'.*-(\d+)\.txt$', filename)
                $if m and int(m.group(1)) >= idx_min and int(m.group(1)) <= idx_max
                    file = os.path.join(folder, filename)
                    $if not header_line
                        header_line = get_header(file)
                    data.append(np.loadtxt(file, skiprows=1))
            t = np.mean(data, axis=0)
            file_out = os.path.join(folder, "avg-%d-%d.txt" % (idx_min, idx_max))
            np.savetxt(file_out, t, header=header_line, fmt='%.6f', comments='')

            return (len(data), file_out)
            return "Averaging %d data files -> %s" % (len(data), file_out)

        # -- instance methods --
        #    data, num_rows, num_cols
        #    cols (column header)
        #    idxs (column index)
        #    c_jump, o_jump, num_bunches, num_orbital, num_channel
        #    normalized

        def read(self, file):
            print("reading %s ..." % file)
            $call read_trxas
            return True

        def normalize(self):
            $call normalize

        def process_perbunch(self, fileout, trig, pre_n_avg, aft_n_avg, n_pnt):
            $(set:mode=perbunch)
            $call process_trxas
        def process_avgbunch(self, fileout, trig, pre_n_avg, aft_n_avg, n_pnt):
            $(set:mode=avgbunch)
            $call process_trxas

subcode: process_trxas
    extra_cols = ["Energy"]
    header_cols = []
    header_cols.extend(extra_cols)
    $for j=0:n_pnt
        header_cols.append("b%d" % j)
        header_cols.append("b%d-diff" % j)

    data_out = np.empty([self.num_rows, len(header_cols)])

    num_extra = len(extra_cols)
    $for i, col in extra_cols
        data_out[:, i] = self.data[:, self.idxs[col]]

    $for i=0:self.num_rows
        row_in = self.data[i,:]
        row_out = data_out[i,num_extra:]
        $call calc_background, pre_n_avg
        $call out_line_b_diff, aft_n_avg

    np.savetxt(fileout, data_out, header=' '.join(header_cols), fmt='%.6f', comments='')

    subcode: calc_background(pre_n_avg) # row_in
        back1, back2, back12 = [], [], []

        $for i=0:self.o_jump # each bunch
            (t1, t2, t12) = (0, 0, 0)
            i0 = self.idxs['c0o0b0'] + trig + i
            $for j=0:$(pre_n_avg)
                $call acc_t12, i0 - (j+1) * self.o_jump
            $call avg_t12, $(pre_n_avg)

            $(for:1,2,12)
                back$1.append(t$1)
        $(if:mode=avgbunch)
            $(for:1,2,12)
                back$1_avg = np.mean(back$1)
        
    subcode: out_line_b_diff(aft_n_avg)
        $for j=0:n_pnt
            a12 = 0
            adiff = 0
            i0 = self.idxs['c0o0b0'] + trig + j*$(aft_n_avg)
            $for i=0:$(aft_n_avg)
                $call get_t12, i0 + i
                $call avg_t12

                $(if:mode=perbunch)
                    b_idx=(i+j*$(aft_n_avg)) % self.o_jump
                    diff = t12 - back12[b_idx]
                $(elif:mode=avgbunch)
                    diff = t12 - back12_avg

                a12+=t12
                adiff+=diff

            a12/=$(aft_n_avg)
            adiff/=$(aft_n_avg)

            row_out[j*2] = a12
            row_out[j*2 + 1] = adiff

    #------------------
    subcode: get_t12(i)
        t1=row_in[$(i)+self.c_jump]
        t2=row_in[$(i)+self.c_jump*2]
    subcode: acc_t12(i)
        t1+=row_in[$(i)+self.c_jump]
        t2+=row_in[$(i)+self.c_jump*2]
    subcode: avg_t12(@n)
        $(if:n)
            t1 /= $(pre_n_avg)
            t2 /= $(pre_n_avg)
        t12=(t1+t2)/2

# The columns are cols[n_c][n_o][n_b],
# thus o_jump is n_b
# and  c_jump is n_b * n_o - [missing bunches in the last orbital]
subcode: read_trxas # file
    header = None
    rows = []
    with open(file) as f:
        $for line in f
            $if line.startswith('#L ')
                header = line[3:]
                $if not re.match(r'#L .* Energy ', line)
                    print("  file is not a energy scan: %s, header: %s..." % (file, line[0:20]))
                    return False
            $elif re.match(r'\d.*', line) and header
                rows.append(line)
    $if not rows
        print("  file empty")
        return False
    $call parse_header
    $call check_header
    self.num_cols = len(rows[0].split())
    self.num_rows = len(rows)
    self.data = np.empty([self.num_rows, self.num_cols], dtype = np.float64)
    $for i, l in rows
        $for j, t in l.split()
            self.data[i, j] = float(t)

    subcode: parse_header
        self.cols = header.split()
        self.idxs = {}
        $(for:c,o,b)
            $1_min = 999
            $1_max = 0

        $foreach i, col in self.cols
            $call update_col_cob
            self.idxs[col] = i    

        # o_jump = num_bunches, c_jump = num_bunches * num_orbitals - missing_bunches_in the last orbital
        self.c_jump = self.idxs['c1o0b0'] - self.idxs['c0o0b0']
        self.o_jump = b_max+1
        self.num_channel = c_max + 1
        self.num_bunches = b_max + 1
        self.num_orbital = o_max  # omitting the last incomplete orbit

        subcode: update_col_cob
            $if RE.match(r'c(\d+)o(\d+)b(\d+)', col)
                $(for:c,o,b and 1,2,3)
                    $1_max = max($1_max, int(RE.m.group($2)))
                    $1_min = min($1_min, int(RE.m.group($2)))

    subcode: check_header
        $(for:c,o,b)
            $call assert, $1_min==0
        $call assert, c_max>=2
        $call assert, self.idxs['c0o0b0']
        $call assert, self.idxs['c1o0b0']

        subcode: assert(cond)
            $if !($(cond))
                print(" check failed for file for $(cond) file: %s" % file)
                return False

subcode: normalize
    $for i=0:self.num_rows
        i0 = self.idxs['c0o0b0']
        avgs = []
        $for j=0:self.num_bunches
            sum = 0.0
            $for k=0:self.num_orbital
                sum += self.data[i, i0 + k * self.num_bunches + j]
            avgs.append(sum / self.num_orbital)
        # -- normalize per bunch
        i0 = self.idxs['c1o0b0']
        $for j=i0:self.num_cols
            self.data[i, j] /= avgs[j % self.num_bunches]
    self.normalized = True
